

TODO (2/15/2020):
[x] create a main menu appstate
[x] change screensize when going into editor mode
    [x] use https://docs.rs/ggez/0.5.1/ggez/graphics/fn.set_mode.html
    [x] create settings menu
    [x] add display settings options
    [x] use this https://docs.rs/ggez/0.5.1/ggez/graphics/fn.set_screen_coordinates.html
        [x] for making the game render up when fullscreened, but leave the UI correct.
[x] rework editor to use new state system
    [x] pass an RC of the character and a path to each of the editors
    [x] have the states update the RC themselves when the save button is pressed
    [x] gradually go through character editor, and fix up sub editors to work properly.
    [] eventually switch over to a setup that opens up new windows itself??
        [] store a path and UI_data for each window, which keeps track of its own update properties
        [] if the windows focus is active, display that window in the render viewportm 
            [] https://docs.rs/imgui/0.3.0/imgui/struct.Ui.html#method.is_window_focused
        [] use the following to stop names from actively being resorted on text_edit
            [] https://docs.rs/imgui/0.3.0/imgui/struct.Ui.html#method.is_item_active

[x] remove dead code
[] rework configuration into self stored config file, rather than ggez stored config file  
    [] move back to official ggez versioning
[x] make button check associated with a controller
[x] controller select
    [x] selectable_players (p1 | p2)
    [x] closure
        [x] takes (option<GamepadId>, option<GamepadId>)
        [x] returns a transition
    [x] if p1 is selectable
        [x] if a gamepad press '<-'
            [x] if p1 isn't selected
                [x] make p1 that gamepad
        [x] if a gamepad press '->' || <B> || <Circle>
            [x] if p1 is selected and the gamepad is p1
                [x] remove it from p1

    [x] if p2 is selectable
        [x] if a gamepad press '<-'
            [x] if p2 isn't selected
                [x] make p2 that gamepad
        [x] if a gamepad press '->' || <B> || <Circle>
            [x] if p2 is selected and the gamepad is p2
                [x] remove it from p2

    [x] if (a gamepad press 'A' || 'start') && gamepad_id is assigned to p1 or p2 && all selectable players are selected
        [x] proceed to following screen
            [x] uses closure to create next state
[x] character select
    [x] contains selected characters
    [x] selection_type
        [x] local(GamePadId)
        [x] network()
    [x] p1: SelectionType
    [x] p2: SelectionType
        [x] when both p1 and p2 have the same local(GamePadId)
            [x] p1 is controlled as long as p1 is unselected
            [x] while p2, if the gamepad presses back and it hasn't selected a character
                [x] deselect p1 and return control
    [x] TBD: Handle Network selection
        [x] 

[] hookup training mode
    [x] create training mode appstate
    [x] have it read the input for p1 to an input buffer
    [x] have it read null input for p2
    [x] pass those to the match
    [x] RENDER
    [x] move to standard array iteration for input buffer
    [x] increase buffer window on input buffer
        [x] for each button press start in the last X frames
            [x] collate what button presses happened before it within Y frames, and pair them
            [x] check if from that point onward, the motion is valid
                [x] if so emit the input

    [x] ASK TWITTER ABOUT SINGLE vs 2/3 ROUNDS


    [x] add replay support
        [x] logger to file
            [x] training_mode
                [x] to training mode folder
            [x] local_vs
            [x] netplay
        [x] load arbitrary file
        [x] save match settings to file
        [x] save inputs to same file
        [x] compression 
        [x] add versioning to it


    [x] rework for dynamic characters
        [x] move to enum basis for everything
        [x] rework macro impls to CharacterTrait with enum_dispatch
        [x] move more impls to macro.rs
        [x] split each macro into its own file
    [x] would_be_hit should generate the entire set of changes so both players can react based off them
        [x] design datastructure 
        [x] each hit creates an action
        [x] combine all the actions into one effect
        [x] for guard crush, we can choose what thing causes the guard crush and ignore the rest of the 
https://www.gresearch.co.uk/article/defunctionalisation/

    [] add sound support
        [x] support hit sound slot
        [x] support hit sound
        [x] support block sound
        [x] support wrongblock sound
        [x] support voice slot 
        [x] support counter hit sound
        [x] handle sound rendering in player_state (so PlayerState generic can be saved properly)
        [x] move sound data for character specific sounds behind an Rc or in the OG Rc        
        [x] consider rewriting all the macros so that the resource data is in a different spot than the game state
        [x] add config for getting sounds
        [x] update editor for global and character sounds
            [x] global
            [x] character
        [x] remove the Player class
        [x] add character specific sounds
        [x] make the damage dealer provide the hit sounds
        [x] make the bullets provide their own hit sounds
    [x] add loading screen
    [x] deprecate the current particle effect system for hits
    [x] move to SDL2 for controller support
    [X] add super flash support
        [x] add super flash
        [x] make sure if 2 people super flash at the same time, both play their animation
        [x] add guard crush cutscene
        [x] implement super flash
        [x] implement guard crush flash
        [x] implement new VFX system ecsk dee
            [x] add global particle list
        [] implement partial super flash
        [] implement super flash sound
            [x] add global sounds to editor for character states
    [] add desync checking via hashing gamestate
        [x] FIX DESYNCS by fixing saving loading data
    [] add meter
        [x] remove orb crushing
        [x] add meter that slowly generates to 100 out of 200
        [x] render it
        [x] rework AttackInfo
            [x] remove attack level
            [x] edit every property for every hit type manually
            [x] on hit
            [x] on block
            [x] on graze
            [x] on wrongblock
            [x] on counterhit
            [x] on guard crush
            [x] on air block
            [x] on air guardcrush
            [x] all of the above have different values for all relevant data
            [x] have this data have meter data
                [x] attacker change
                [x] defender change
        [x] have dealing wrongblocks increase the meter
        [x] have it slowly decrease after its above 100
        [x] have BE cost meter
        [x] have melee restitution cost meter
        [x] add + meter on AttackInfo so attacks can generate the meter on hit/block/wrongblock
        [x] add chain_shift
            [x] remove chain_shift
        [x] have moving forward give meter
        [x] have backdashing and moving backward lose meter
        [x] add meter to editor 
        
        [x] add defensive lock debuff
            [x] flag
                [x] Modifier
                [x] reset flag
            [x] add mechanic
            [x] add ui
            [x] shield icon that is X'd when the debuff is on
    [] improve UI
        [] add tick marks 
        [] add combo ui
    [x] add self chaining for 2a/5a
    [x] ground bounce loses energy
    [] add palletes
    [] add rounds
        [x] first 5 seconds have a countdown
            [x] roudn start animation
            [x] text/graphic showing count down
        [] hitting 0 and being hit by a lethal attack ends the game
            [] play a small animation at the end of the game for the winner
        [] ending the game brings you to character select/retry/main menu
            [] have a win quote
        [] have multiple rounds 
    [] button check at character select 
        [] on press start
    [x] move to E button
    [] create object system
        [] decide on structure and how to process
            [] decide on how to determine state transitions
        [] migrate all bullets into objects
        [] standardize functionality that bullets need/input parameters
            [] position

            [] color?? (just make different bulelts for idfferent colors)
    [] make sound loading look for soundfiles that appear in the global directory, but not necessarily in any particular folder
    [] rework chaining description
        [] hit
            [] allow based on move type
            [] allow based on specific state
            [] disallow based on specific state overrides allow based on move type
    [] your bullets go away on getting hit
        [] maybe attacker gets extra meter for destroying bullets this way
    [] controller support update
        [] add ltrigger/rtrigger
        [] add left/right stick support
        [] keyboard support
    [] add untech
        [] when you enter untech without limit bounce tech
    [] update attack AttackInfo
        [] add head/foot/body
        [x] remove attack levels, change to manual hitstun/blockstun selection
            [x] hit
            [x] airhit
            [x] counterhit
            [x] block
            [x] wrongblock
            [x] airblock
    [] move to u32 for current_frame
    [] implement SMP
        [] more like same move limit
        [] the first move in a combo is NOT recorded
    [] add hardlimits on velocity due to gravity
    [] integrate typesafe appstate transitions instead of Boxed Closures 
    [] create an actual basic UI that's mirrored properly
    [] add pause menu
    [] add box<character> to gameplay
        [x] done with enum dispatch
    [] expose each character to the training_mode so it can reset its hp
        [] expose training mode options via additional methods on game_match?
        [] expose it via character behavior, and just expose the characters instead?
    [] reset HP when player hits idle
    [] handle standing reset limit
        [] right now if you are standing and hit limit, you expire to standing idle rather than a KD
    [] treat triggers as buttons for the purpose of this game
        [] treating left stick as a dpad for the purpose of the game
    [] have replays handle multiple rounds
    [x] 4ab to 6ab 
    [] add better knockdowns
    [] add value scaler, so that things in the 'Add' blend mode can fade to invisible 
        [] add two things to shader as a uniform (mimic u_Rate)
            [] value
            [] alpha
        [] sprite gets the value of both fields to send to the shader 
        [x] Modifiers struct has parameters for these fields which default to Constant(time=0.0, value=1.0)
    [] remove depedency "keyframe" and use own impl
    [] use left stick/right stick for directional input too
    [] make goldensun style particle effects
    [] move editor to a special version of training mode
    [] consider adding ]E[ input to cancel to fly_end to remove fly special handling
    [] move all weird constants into either Rust constants or loaded from a file
    [] add compression for sameinputs in replay to reduce replay file size
    [x] superjump macro is 1/2/3AB in neutral
        [x] remove this
    [x] rollback netcode
    [x] fix copy paste 

random key: 4D 6D 9C 6C 2B